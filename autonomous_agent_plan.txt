# Autonomous Agent Plan - Llama 4 Agentic Browser Automation

## Status: ✅ UPDATED (2025-01-06) - Direct Playwright Implementation

All critical capabilities confirmed:
- ✅ Together AI supports OpenAI-compatible function calling
- ✅ Llama 4 Maverick has native multimodal vision (beats GPT-4o)
- ✅ Playwright Python async API (production-ready)
- ✅ Direct tool calling (no middleware needed)
- ❌ MCP Python SDK - ABANDONED (timeout bugs, hanging issues)

## Vision
Transform from scripted browser automation → autonomous Llama 4 agent using tool calling
Similar to Claude Code's agentic behavior: screenshot → reason → act → repeat

**Cost:** Not a concern (user approved)

## Architecture (Updated)

```
User Goal → Agent Loop → Llama 4 (vision + reasoning) → Tool Calls → Direct Playwright Python
              ↑                                                              ↓
              └──────────────────── Screenshot + State ─────────────────────┘
```

**Key Change:** Direct Playwright Python execution instead of MCP SDK middleware

## Components

### 1. Browser Automation: Playwright Python (Direct)
**Package:** `playwright` (async API)
**Runtime:** Python 3.13
**Install:** `pip install playwright && playwright install chromium`

**Tools implemented as Python functions:**
- `navigate(url: str)` - Navigate to URL
- `screenshot() -> bytes` - Take screenshot of current page
- `click(selector: str)` - Click element by CSS selector
- `fill(selector: str, value: str)` - Fill form field
- `evaluate(script: str) -> Any` - Execute JavaScript, return result
- `get_page_content() -> str` - Get page text content
- `wait(seconds: float)` - Wait for specified time

**Configuration:**
- **ALWAYS use headless mode**: Set in browser launch
- Persistent browser/page instance across agent loop
- Real Chromium browser environment
- Screenshots saved to disk for vision input

### 2. Search Integration: Direct API (Optional)
**Option 1:** Brave Search API (direct HTTP calls)
**Option 2:** Defer to Phase 2

**API Key:** User will provide BRAVE_API_KEY in .env (if needed)

### 3. Agent Loop
**File:** `agent_loop.py`

**Flow:**
1. Initialize: Load goal, start browser (headless), create page
2. Loop:
   a. Take screenshot (save to disk)
   b. Get page state (URL, title via JavaScript)
   c. Build context: [goal, history, current_state, screenshot path]
   d. Call Llama 4 with tools enabled (pass screenshot as vision input)
   e. Parse tool calls from response (OpenAI format)
   f. Execute tools via direct Playwright Python calls
   g. Check if goal achieved
   h. Repeat or exit
3. Cleanup: Save state, close browser

**Parameters:**
- `max_iterations: int = 50` - Safety limit
- `goal: str` - Natural language goal
- `client_id: str` - For screenshot dirs, auth state

**Note:** Browser always runs headless (configured in launch)

### 4. Llama 4 Integration
**File:** `together_ai/agent_client.py`

**Model:** meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8

**Features:**
- Tool/function calling support (OpenAI format)
- Vision input (base64-encoded screenshots)
- System prompt for agentic behavior
- Conversation history management

**System Prompt Structure:**
```
You are an autonomous browser automation agent.
Goal: {goal}

You have access to browser control tools (navigate, click, fill, evaluate, etc).
Analyze screenshots, reason about next steps, and use tools to achieve the goal.

When goal is achieved, explain what was accomplished and stop.
```

### 5. Tool Layer (New - Replaces MCP SDK)
**File:** `browser_tools.py`

**Purpose:** Wrap Playwright Python calls in tool-callable functions

**Example:**
```python
async def navigate(page: Page, url: str) -> str:
    """Navigate to a URL."""
    await page.goto(url)
    return f"Navigated to {url}"

async def screenshot(page: Page, path: str) -> str:
    """Take screenshot."""
    await page.screenshot(path=path)
    return f"Screenshot saved to {path}"
```

**Tool definitions for Llama 4:**
```python
tools = [
    {
        "type": "function",
        "function": {
            "name": "navigate",
            "description": "Navigate to a URL",
            "parameters": {
                "type": "object",
                "properties": {
                    "url": {"type": "string", "description": "URL to navigate to"}
                },
                "required": ["url"]
            }
        }
    },
    # ... more tools
]
```

### 6. Client Configuration (Non-Technical)
**File:** `clients/<client_id>/agent_config.yaml`

**Format - Plain English:**
```yaml
website: https://sandbar.example.com

what_to_do: |
  1. Log in with my username and password
  2. Go to the alerts dashboard
  3. Look at 2 customers who have open alerts
  4. For each customer:
     - Read their transaction details
     - Decide if it looks suspicious or normal
     - If the transaction is over $10,000, escalate it to management
     - If it involves Iran, North Korea, Syria, or Cuba, flag it
     - Otherwise approve it
     - Write down why I made that decision
     - Submit my decision
  5. Make sure both decisions were saved

when_finished: |
  I'm done when I've reviewed exactly 2 customers and all my decisions
  are submitted and saved in the system.

important_notes:
  - "Always explain your reasoning"
  - "Never approve without reading the details first"
  - "Stop if something seems wrong with the website"
```

**Design Philosophy:**
- Natural language instructions (like telling a human)
- No programming concepts (loops, conditionals, variables)
- Client-friendly - can be filled out by non-technical users
- Agent infers logic from context

### 7. Client Interface
**File:** `agent_client.py`

**Usage:**
```python
from agent_loop import BrowserAgent
import yaml

config = yaml.safe_load(open("clients/sandbar/agent_config.yaml"))

agent = BrowserAgent(
    client_id="sandbar",
    config=config,
    max_iterations=50
)

result = agent.run()
print(result.success, result.steps_taken, result.final_state)
```

## Implementation Plan

### Phase 1: Direct Playwright Setup (Day 1)
- [x] Abandon MCP Python SDK approach (timeout/hanging bugs)
- [ ] Create browser_tools.py with Playwright wrapper functions
- [ ] Update agent_loop.py to use direct Playwright calls
- [ ] Test basic navigate → screenshot → evaluate cycle

### Phase 2: Agent Loop Core (Day 1-2)
- [ ] Integrate TogetherAI with tool calling (reuse existing code)
- [ ] Implement screenshot → base64 encoding for vision
- [ ] Build context manager (history, state)
- [ ] Add safety limits (max iterations, timeouts)
- [ ] Connect tool execution to Playwright functions

### Phase 3: Testing & Refinement (Day 2-3)
- [ ] Test on Amazon example (simple goal)
- [ ] Test on Sandbar (complex auth + decisions)
- [ ] Compare performance vs scripted approach
- [ ] Tune prompts, iteration limits
- [ ] Add error recovery patterns

### Phase 4: Search Integration (Optional - Day 3+)
- [ ] Add Brave Search API integration (direct HTTP)
- [ ] Test search from agent for help/troubleshooting
- [ ] Add search examples to system prompt

### Phase 5: Client Migration (Day 3+)
- [ ] Update onboard_client.py to generate agent-based clients
- [ ] Migrate existing clients (optional)
- [ ] Document agent patterns in CLAUDE.md
- [ ] Add agent examples to ONBOARDING.md

## Key Decisions

### MCP SDK Abandoned - Why?
**Issues found:**
- macOS KqueueSelector hanging bug (Issue #547)
- Hardcoded 5-second ping timeout (not configurable)
- ClientRequest timeouts for operations >5 seconds
- Server hanging on close if browser_close not called
- WSL/Windows timeout issues
- Multiple unresolved issues across environments

**Decision:** Use Playwright Python directly
**Rationale:**
- Production-ready async API
- No middleware bugs/timeouts
- Direct control over browser
- Same autonomous behavior (tool calling pattern)
- Deployable anywhere (pure Python)

### Tool Granularity
**Decision:** Expose low-level tools (navigate, click, fill, evaluate)
**Rationale:**
- LLM can compose complex actions
- Flexibility for unforeseen workflows
- Mirrors Claude Code's approach

### Vision vs Text State
**Decision:** Use both - screenshots for visual reasoning, text for context
**Rationale:**
- Vision shows UI state, layout, visual elements
- Text provides URL, page content for search/reasoning
- Together = comprehensive understanding

### Error Handling
**Decision:** LLM-driven recovery with retry budget
**Rationale:**
- LLM can reason about errors and try different approaches
- Set retry limits to prevent infinite loops
- Log failures for debugging

### Auth Caching
**Decision:** Keep storage_state pattern, add as parameter
**Rationale:**
- Auth is expensive (2FA, etc)
- Agent can decide when to use cached vs fresh login
- Backward compatible with existing pattern

## Success Metrics

**Agent should be able to:**
1. Navigate unfamiliar websites without pre-scripted steps
2. Adapt to UI changes (selectors, layouts)
3. Complete Sandbar workflow end-to-end autonomously
4. Match or exceed scripted performance (success rate, time)
5. Self-debug: see errors, try alternative approaches

## Files to Create/Update

```
autonomous_agent/
  browser_tools.py           - Playwright wrapper functions + tool definitions
  agent_loop.py              - Main agent loop (updated for direct Playwright)
  together_ai/
    agent_client.py          - Llama 4 with tool calling + vision (reuse existing)

  tests/
    test_agent_amazon.py     - Simple navigation test
    test_agent_sandbar.py    - Complex workflow test

  clients/
    <client_id>/
      agent_config.yaml      - Natural language config
```

**Removed:**
- mcp_config.json (not needed - no MCP SDK)
- MCP SDK dependencies

## Dependencies

**Updated packages:**
- `playwright` - Browser automation (async API)
- `pillow==11.1.0` - Image encoding for vision
- `openai` - Together AI client (OpenAI-compatible)
- `python-dotenv` - Environment variables

**requirements.txt:**
```
playwright
pillow==11.1.0
openai
python-dotenv
pyyaml
```

**Installation:**
```bash
source venv/bin/activate
pip install playwright pillow==11.1.0 openai python-dotenv pyyaml
playwright install chromium
```

**Python Version:**
```bash
python3.13 --version  # Use Python 3.13
```

## Updated Architecture Details

### 1. Together AI Integration (No Changes)
**File:** `together_ai/agent_client.py`

```python
from openai import OpenAI
import base64

client = OpenAI(
    api_key=os.getenv("TOGETHER_API_KEY"),
    base_url="https://api.together.xyz/v1"
)

# Convert screenshot to base64
with open(screenshot_path, "rb") as f:
    image_b64 = base64.b64encode(f.read()).decode()

response = client.chat.completions.create(
    model="meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8",
    messages=[
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": [
            {"type": "text", "text": "What should I do next?"},
            {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{image_b64}"}}
        ]}
    ],
    tools=tool_definitions,
    max_tokens=2000
)

# Parse tool calls
if response.choices[0].message.tool_calls:
    for tool_call in response.choices[0].message.tool_calls:
        function_name = tool_call.function.name
        arguments = json.loads(tool_call.function.arguments)
        # Execute via Playwright wrapper
```

### 2. Browser Tools Layer (New)
**File:** `browser_tools.py`

```python
from playwright.async_api import Page
from typing import Any, Dict, List

async def navigate(page: Page, url: str) -> str:
    """Navigate to a URL."""
    await page.goto(url, wait_until="domcontentloaded")
    return f"Navigated to {url}"

async def screenshot(page: Page, path: str) -> str:
    """Take screenshot of current page."""
    await page.screenshot(path=path, full_page=True)
    return f"Screenshot saved to {path}"

async def click(page: Page, selector: str) -> str:
    """Click element by CSS selector."""
    await page.click(selector)
    return f"Clicked {selector}"

async def fill(page: Page, selector: str, value: str) -> str:
    """Fill form field."""
    await page.fill(selector, value)
    return f"Filled {selector} with: {value}"

async def evaluate(page: Page, script: str) -> Any:
    """Execute JavaScript and return result."""
    result = await page.evaluate(script)
    return result

async def wait_for_timeout(page: Page, seconds: float) -> str:
    """Wait for specified seconds."""
    await page.wait_for_timeout(seconds * 1000)
    return f"Waited {seconds} seconds"

# Tool definitions for Llama 4
TOOL_DEFINITIONS = [
    {
        "type": "function",
        "function": {
            "name": "navigate",
            "description": "Navigate to a URL",
            "parameters": {
                "type": "object",
                "properties": {
                    "url": {"type": "string", "description": "URL to navigate to"}
                },
                "required": ["url"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "click",
            "description": "Click an element by CSS selector",
            "parameters": {
                "type": "object",
                "properties": {
                    "selector": {"type": "string", "description": "CSS selector"}
                },
                "required": ["selector"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "fill",
            "description": "Fill a form field",
            "parameters": {
                "type": "object",
                "properties": {
                    "selector": {"type": "string", "description": "CSS selector"},
                    "value": {"type": "string", "description": "Value to fill"}
                },
                "required": ["selector", "value"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "evaluate",
            "description": "Execute JavaScript in browser",
            "parameters": {
                "type": "object",
                "properties": {
                    "script": {"type": "string", "description": "JavaScript code"}
                },
                "required": ["script"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "wait_for_timeout",
            "description": "Wait for specified seconds",
            "parameters": {
                "type": "object",
                "properties": {
                    "seconds": {"type": "number", "description": "Seconds to wait"}
                },
                "required": ["seconds"]
            }
        }
    }
]

# Tool executor
async def execute_tool(page: Page, tool_name: str, arguments: Dict[str, Any]) -> Any:
    """Execute a tool by name with arguments."""
    tools = {
        "navigate": navigate,
        "screenshot": screenshot,
        "click": click,
        "fill": fill,
        "evaluate": evaluate,
        "wait_for_timeout": wait_for_timeout
    }

    tool_func = tools.get(tool_name)
    if not tool_func:
        raise ValueError(f"Unknown tool: {tool_name}")

    return await tool_func(page, **arguments)
```

## Critical Findings & Limitations

### ✅ Image Context Management - PRODUCTION DIMENSIONS
- **Viewport: 1280x1500 pixels** (from existing playwright_client.py)
- **Full-page screenshots**: Capture entire page height
- **Token usage per image**: ~3,045-6,000 tokens depending on page height
- **Context strategy**: Keep only last 10 screenshots in LLM context
- **All screenshots saved to disk** with metadata JSON
- **Agent references past actions via text summaries**, not re-sending images

### ✅ Tool Calling with Retry Logic
1. **Together AI handles parsing**: OpenAI-compatible API
2. **Format errors**: Model can occasionally fail to emit tool calls correctly
3. **Retry strategy**:
   - No tool calls detected → retry with "please use tools" hint
   - Malformed JSON → retry with format correction
   - Max 3 retries per action
   - Log failures for debugging

### ✅ Direct Playwright Benefits
- **No middleware timeouts**: Direct async control
- **Production-ready**: Playwright is battle-tested
- **Full control**: Can customize any behavior
- **Debugging**: Standard Python stack traces
- **Portable**: Works on any OS with Python

## Updated Success Metrics

1. **Autonomy**: Complete Sandbar workflow with zero pre-scripting
2. **Adaptability**: Handle UI changes without code updates
3. **Performance**: Match scripted workflow success rate
4. **Vision Quality**: Accurately interpret UI state from screenshots
5. **Self-debugging**: Recover from errors autonomously

## Next Steps

1. ✅ Architecture updated - Direct Playwright instead of MCP SDK
2. [ ] Rename mcp_agent/ → autonomous_agent/
3. [ ] Create browser_tools.py with Playwright wrappers
4. [ ] Update agent_loop.py to use direct Playwright
5. [ ] Test basic agent loop with Llama 4
6. [ ] Test on Amazon (simple goal)
7. [ ] Test on Sandbar (complex workflow)
